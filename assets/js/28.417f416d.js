(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{882:function(e,t,v){"use strict";v.r(t);var _=v(5),r=Object(_.a)({},function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"_1-现实问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-现实问题"}},[e._v("#")]),e._v(" 1.现实问题")]),e._v(" "),v("p",[e._v("在浏览器支持 ES 模块之前，JavaScript 并没有提供的原生机制让开发者以模块化的方式进行开发。这也正是我们对 “打包” 这个概念熟悉的原因：使用工具抓取、处理并将我们的源码模块串联成可以在浏览器中运行的文件。")]),e._v(" "),v("p",[e._v("时过境迁，我们见证了诸如 "),v("a",{attrs:{href:"https://webpack.js.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpack"),v("OutboundLink")],1),e._v("、"),v("a",{attrs:{href:"https://rollupjs.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Rollup"),v("OutboundLink")],1),e._v(" 和 "),v("a",{attrs:{href:"https://parceljs.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Parcel"),v("OutboundLink")],1),e._v(" 等工具的变迁，它们极大地改善了前端开发者的开发体验。")]),e._v(" "),v("p",[e._v("然而，当我们开始构建越来越大型的应用时，需要处理的 JavaScript 代码量也呈指数级增长。包含数千个模块的大型项目相当普遍。我们开始遇到性能瓶颈 —— 使用 JavaScript 开发的工具通常需要很长时间（甚至是几分钟！）才能启动开发服务器，即使使用 HMR，文件修改后的效果也需要几秒钟才能在浏览器中反映出来。如此循环往复，迟钝的反馈会极大地影响开发者的开发效率和幸福感。")]),e._v(" "),v("p",[e._v("Vite 旨在利用生态系统中的新进展解决上述问题：浏览器开始原生支持 ES 模块，且越来越多 JavaScript 工具使用编译型语言编写。")]),e._v(" "),v("h2",{attrs:{id:"_2-缓慢的服务器启动"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-缓慢的服务器启动"}},[e._v("#")]),e._v(" 2.缓慢的服务器启动")]),e._v(" "),v("p",[e._v("当冷启动开发服务器时，基于打包器的方式启动必须优先抓取并构建你的整个应用，然后才能提供服务。")]),e._v(" "),v("p",[e._v("Vite 通过在一开始将应用中的模块区分为 "),v("strong",[e._v("依赖")]),e._v(" 和 "),v("strong",[e._v("源码")]),e._v(" 两类，改进了开发服务器启动时间。")]),e._v(" "),v("ul",[v("li",[v("p",[v("strong",[e._v("依赖")]),e._v(" 大多为在开发时不会变动的纯 JavaScript。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。依赖也通常会存在多种模块化格式（例如 ESM 或者 CommonJS）。")]),e._v(" "),v("p",[e._v("Vite 将会使用 "),v("a",{attrs:{href:"https://esbuild.github.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("esbuild"),v("OutboundLink")],1),e._v(" "),v("a",{attrs:{href:"https://vitejs.cn/guide/dep-pre-bundling.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("预构建依赖"),v("OutboundLink")],1),e._v("。Esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。")])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("源码")]),e._v(" 通常包含一些并非直接是 JavaScript 的文件，需要转换（例如 JSX，CSS 或者 Vue/Svelte 组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载（例如基于路由拆分的代码模块）。")]),e._v(" "),v("p",[e._v("Vite 以 "),v("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules",target:"_blank",rel:"noopener noreferrer"}},[e._v("原生 ESM"),v("OutboundLink")],1),e._v(" 方式提供源码。这实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入代码，即只在当前屏幕上实际使用时才会被处理。")]),e._v(" "),v("p",[v("img",{attrs:{src:"https://vitejs.cn/assets/bundler.37740380.png",alt:"基于打包器的开发服务器"}})]),e._v(" "),v("p",[v("img",{attrs:{src:"https://vitejs.cn/assets/esm.3070012d.png",alt:"基于 ESM 的开发服务器"}})])])]),e._v(" "),v("h2",{attrs:{id:"_3-缓慢的更新"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-缓慢的更新"}},[e._v("#")]),e._v(" 3.缓慢的更新")]),e._v(" "),v("p",[e._v("基于打包器启动时，重建整个包的效率很低。原因显而易见：因为这样更新速度会随着应用体积增长而直线下降。")]),e._v(" "),v("p",[e._v("一些打包器的开发服务器将构建内容存入内存，这样它们只需要在文件更改时使模块图的一部分失活["),v("a",{attrs:{href:"https://vitejs.cn/guide/why.html#footnote-1",target:"_blank",rel:"noopener noreferrer"}},[e._v("1]"),v("OutboundLink")],1),e._v("，但它也仍需要整个重新构建并重载页面。这样代价很高，并且重新加载页面会消除应用的当前状态，所以打包器支持了动态模块热重载（HMR）：允许一个模块 “热替换” 它自己，而不会影响页面其余部分。这大大改进了开发体验 —— 然而，在实践中我们发现，即使采用了 HMR 模式，其热更新速度也会随着应用规模的增长而显著下降。")]),e._v(" "),v("p",[e._v("在 Vite 中，HMR 是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失活["),v("a",{attrs:{href:"https://vitejs.cn/guide/why.html#footnote-1",target:"_blank",rel:"noopener noreferrer"}},[e._v("1]"),v("OutboundLink")],1),e._v("（大多数时候只是模块本身），使得无论应用大小如何，HMR 始终能保持快速更新。")]),e._v(" "),v("p",[e._v("Vite 同时利用 HTTP 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 "),v("code",[e._v("304 Not Modified")]),e._v(" 进行协商缓存，而依赖模块请求则会通过 "),v("code",[e._v("Cache-Control: max-age=31536000,immutable")]),e._v(" 进行强缓存，因此一旦被缓存它们将不需要再次请求。")]),e._v(" "),v("p",[e._v("一旦你体验到 Vite 的神速，你是否愿意再忍受像曾经那样使用打包器开发就要打上一个大大的问号了。")]),e._v(" "),v("h2",{attrs:{id:"_4-为什么生产环境仍需打包"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-为什么生产环境仍需打包"}},[e._v("#")]),e._v(" 4.为什么生产环境仍需打包")]),e._v(" "),v("p",[e._v("尽管原生 ESM 现在得到了广泛支持，但由于嵌套导入会导致额外的网络往返，在生产环境中发布未打包的 ESM 仍然效率低下（即使使用 HTTP/2）。为了在生产环境中获得最佳的加载性能，最好还是将代码进行 tree-shaking、懒加载和 chunk 分割（以获得更好的缓存）。")]),e._v(" "),v("p",[e._v("要确保开发服务器和生产环境构建之间的最优输出和行为一致并不容易。所以 Vite 附带了一套 "),v("a",{attrs:{href:"https://vitejs.cn/guide/features.html#build-optimizations",target:"_blank",rel:"noopener noreferrer"}},[e._v("构建优化"),v("OutboundLink")],1),e._v(" 的 "),v("a",{attrs:{href:"https://vitejs.cn/guide/build.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("构建命令"),v("OutboundLink")],1),e._v("，开箱即用。")]),e._v(" "),v("h2",{attrs:{id:"_5-为何不用-esbuild-打包"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-为何不用-esbuild-打包"}},[e._v("#")]),e._v(" 5.为何不用 ESBuild 打包？")]),e._v(" "),v("p",[e._v("虽然 "),v("code",[e._v("esbuild")]),e._v(" 快得惊人，并且已经是一个在构建库方面比较出色的工具，但一些针对构建 "),v("em",[e._v("应用")]),e._v(" 的重要功能仍然还在持续开发中 —— 特别是代码分割和 CSS 处理方面。就目前来说，Rollup 在应用打包方面更加成熟和灵活。尽管如此，当未来这些功能稳定后，我们也不排除使用 "),v("code",[e._v("esbuild")]),e._v(" 作为生产构建器的可能。")]),e._v(" "),v("h2",{attrs:{id:"_6-主流构建工具对比"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-主流构建工具对比"}},[e._v("#")]),e._v(" 6.主流构建工具对比")]),e._v(" "),v("p",[e._v("构建工具指能自动对代码执行检验、转换、压缩等功能的工具。常见功能包括：代码转换、代码打包、代码压缩、HMR、代码检验。构建工具也随着前端技术的发展，从Browserify、Gulp到Parcel，从Webpack到Rollup，一直到最近比较火的面向非打包的Snowpack和Vite。")]),e._v(" "),v("p",[v("strong",[e._v("Browserify")])]),e._v(" "),v("ul",[v("li",[e._v("预编译模块化方案（文件打包工具）")]),e._v(" "),v("li",[e._v("Browserify基于流方式干净灵活")]),e._v(" "),v("li",[e._v("遵循commonJS规范打包JS")]),e._v(" "),v("li",[e._v("可引入插件打包CSS等其他资源（非原生能力）")])]),e._v(" "),v("p",[v("strong",[e._v("Gulp")])]),e._v(" "),v("ul",[v("li",[e._v("基于流的自动化构建工具（工程化）")]),e._v(" "),v("li",[e._v("配置复杂度高，偏向编程式，需要定义task处理构建")]),e._v(" "),v("li",[e._v("支持监听读写文件")]),e._v(" "),v("li",[e._v("可搭配Browserify等模块化工具来使用")])]),e._v(" "),v("p",[v("strong",[e._v("Parcel")])]),e._v(" "),v("ul",[v("li",[e._v("极速打包（工程化：极速0配置）")]),e._v(" "),v("li",[e._v("零配置，但造成了配置不灵活，内置常见场景的构建方案及其依赖，无需再次安装（babel等）")]),e._v(" "),v("li",[e._v("以html入口，自动检测和打包依赖")]),e._v(" "),v("li",[e._v("不支持SourceMap")]),e._v(" "),v("li",[e._v("无法Tree-shaking")])]),e._v(" "),v("p",[v("strong",[e._v("Webpack")])]),e._v(" "),v("ul",[v("li",[e._v("预编译模块化方案（工程化：大而全）")]),e._v(" "),v("li",[e._v("通过配置文件达到一站式配置")]),e._v(" "),v("li",[e._v("loader进行资源转换，功能全面（css+js+icon+front）")]),e._v(" "),v("li",[e._v("插件丰富，灵活扩展")]),e._v(" "),v("li",[e._v("社群庞大")]),e._v(" "),v("li",[e._v("大型项目构建慢")])]),e._v(" "),v("p",[v("strong",[e._v("Rollup")])]),e._v(" "),v("ul",[v("li",[e._v("基于ES6打包（模块打包工具）")]),e._v(" "),v("li",[e._v("Tree-shaking")]),e._v(" "),v("li",[e._v("打包文件小且干净，执行效率更高")]),e._v(" "),v("li",[e._v("更专注于JS打包")])]),e._v(" "),v("p",[v("strong",[e._v("Snowpack")])]),e._v(" "),v("ul",[v("li",[e._v("基于ESM运行时编译（工程化：ESM运行时）")]),e._v(" "),v("li",[e._v("无需递归循环依赖组装依赖树")]),e._v(" "),v("li",[e._v("默认输出单独的构建模块（未打包），可选择不同打包器（webpack、rollup等）")])]),e._v(" "),v("p",[v("strong",[e._v("Vite")])]),e._v(" "),v("ul",[v("li",[e._v("基于ESM运行时打包")]),e._v(" "),v("li",[e._v("借鉴了Snowpack")]),e._v(" "),v("li",[e._v("生产环境使用Rollup，集成度更高，相比Snowpack支持多页面、库模式、动态导入自动polyfill等")])]),e._v(" "),v("h2",{attrs:{id:"_7-相比webpack区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-相比webpack区别"}},[e._v("#")]),e._v(" 7.相比webpack区别")]),e._v(" "),v("p",[v("strong",[e._v("1.webpack会先打包")]),e._v("，然后启动开发服务器，请求服务器时直接给予打包结果。")]),e._v(" "),v("p",[v("strong",[e._v("2.由于vite在启动的时候不需要打包")]),e._v("，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。当浏览器请求某个模块时，再根据需要对模块内容进行编译。这种按需动态编译的方式，极大的缩减了编译时间，项目越复杂、模块越多，vite的优势越明显")]),e._v(" "),v("p",[v("strong",[e._v("3.由于现代浏览器本身就支持ES Module")]),e._v("，会自动向依赖的Module发出请求。vite充分利用这一点，将开发环境下的模块文件，就作为浏览器要执行的文件，而不是像webpack那样进行打包合并。(代码需开启本地服务才能运行，否则会产生跨域错误)")]),e._v(" "),v("p",[v("strong",[e._v("4.vite是按需加载，webpack是全部加载")]),e._v("**：在HMR（热更新）方面，当改动了一个模块后，vite仅需让浏览器重新请求该模块即可，不像webpack那样需要把该模块的相关依赖模块全部编译一次，效率更高。")]),e._v(" "),v("p",[v("strong",[e._v("5.vite的优势在开发环境")]),e._v("**：当需要打包到生产环境时，vite使用传统的rollup（也可以自己手动安装webpack来）进行打包，因此，vite的主要优势在开发阶段。另外，由于vite利用的是ES Module，因此在代码中（除了vite.config.js里面，这里是node的执行环境）"),v("strong",[e._v("不可以使用CommonJS")])]),e._v(" "),v("Vssue")],1)},[],!1,null,null,null);t.default=r.exports}}]);